\chapter{Logique} \label{chapter:logique}
\section{Introduction}
Lorsque nous avons conçu notre logique, nous avons choisi de la diviser en 2
parties majeures, l'une chargée de décrire l'état actuel du jeu, la deuxième
étant chargée de contrôler la première.

C'est pourquoi, nous avons choisi d'utiliser une
state-machine pour contrôler le jeu.
Nous avons donc divisé le jeu en plusieurs états, qui sont les phases du jeu de base.

\section{Diagramme états-transitions}

\mfigure[H]{width=\linewidth}{sm_logic}{Diagramme états-transitions de la logique}{sm::logic} 

Le diagramme ci-dessus présente le fonctionnement global de la logique à travers
les changements de phases du jeu.

Lorsque le jeu est lancé, nous rentrons automatiquement dans la phase «
Recrutement du staff» qui effectue le calculer le nombre de
personnes composant le staff des joueurs.
Une fois ce calcul fait le serveur passe à la phase «Détermination du premier joueur».

La détermination du premier joueur se fait selon les règles, une fois ce joueur
déterminé, on passe à la phase suivante, la phase d'action si l'on est au premier
tour, sinon la phase de marketing.

La phase d'action est-elle même composée d'une state-machine pour simplifier la
réalisation de certaines actions, comme les batailles.

Pour la phase d'action, comme pour la phase de marketing, on passe à l'état
suivant lorsque tous les joueurs ont joué, ou si l'on a terminé la partie.
Dans le cas où l'on a terminé la partie, on passe dans l'état final dans lequel
on détermine les éventuelles gagnants.

\section{Diagrammes de classes}
\subsection{États logiques}

Le diagramme de classe suivant correspond à l'implémentation de la state machine
dans la logique.

\mfigure[H]{width=\linewidth}{cl_logic_states}{Diagramme de classe des états}{cl::logic_states} 

L'état final est ici représenté par l'état « GameEndedState », qui s'occupe de
déterminer les vainqueurs éventuelles de la partie.
De plus nous avons choisi de différencier l'implementation de la phase de
recrutement en fonction du tour pour éviter de vérifier à quel tour on est.
Il en est de même pour la phase de sélection du premier joueur.

Nous avons choisi de créer un état abstrait « GameState » pour
représenter un état du jeu, cet état doit stocker le GameBoard\footnote{Le GameBoard
  est une classe représentant le plateau de jeu.}
qui permet aux états d'intéragir sur le jeu.

\subsection{Données de la logique}

Dans l'UML suivant on retrouve les classes qui ne contiennent que des données,
ainsi que les autres systèmes pour gérer le jeu.
Ces classes sont les suivantes:
\begin{itemize}
    \item Studio
    \item FactionType
    \item Player
    \item UnitBuffedCharacteristics
    \item UnitBasicCharacteristics
    \item UnitCostModifier
    \item UnitCounter
    \item Unit
    \item UnitType
    \item Zone
    \item UnitType
    \item GameMap
    \item UnitLevel
    \item GameBoard
    \item MarketingLadder
\end{itemize}

\mfigure[H]{width=\linewidth}{cl_logic}{Diagramme de classe de la logique}{cl::logic}

On retrouve également deux autres systèmes permettant de gérer le jeu.
Le premier étant le système des buffs, chaque joueur, représenté par la classe
«Player», possède un «BuffsManager» qui permet de gérer les buffs du joueur.
Les buffs sont ajoutés dans les «BuffsManager» des joueurs concernés par
celui-ci.

«Buff» est une classe abstraite dont l'implémentation se doit d'écouter des events
afin de s'appliquer quand les conditions sont remplies.
La classe «BuffMask» permet de modifier les caractéristiques d'une unité en
l'ajoutant dans la classe «UnitBuffedCharacteristics» d'un joueur.
La classe «UnitBasicCharacteristics» définit les caractéristiques de base de l'unité.

Les SelfActivables et Activables permettent de débloquer les capacités («Capacity») des
joueurs au cours de la partie, lorsque les conditions nécessaires à l'activation
de la capacité sont remplies.

