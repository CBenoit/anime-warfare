\chapter{Logique} \label{chapter:logique}

Pour concevoir la logique, nous avons choisi d'utiliser une
state-machine\footnote{State-machine: Automate fini} afin d'intéragir avec le
reste de la logique.

Lorsque le jeu est lancé, nous rentrons automatiquement dans l'état «
Recrutement du staff» qui nous permet d'effectuer le calcul des points de staff.
Une fois ce calcul fait le serveur passe à la détermination du premier joueur.

La détermination du premier joueur se fait selon les règles, une fois ce joueur
déterminé, on passe à l'état suivant, la phase d'action si l'on est au premier
tour, sinon on passe à la phase de marketing.

La phase d'action est composé d'une state machine afin d'effectuer les
batailles.

Pour la phase d'action, comme pour la phase de marketing, on passe à l'état
suivant lorsque tous les joueurs ont joué, ou si l'on a terminé la partie.

Dans le cas ou l'on a terminé la partie, on passe dans l'état final et le jeu
est terminé.


Le diagramme de classe suivant correspond à l'implementation de la state machine
dans la logique.
L'état final est ici représenté par l'état « GameEndedState », qui s'occupe de
déterminer les vainqueurs de la partie.
De plus nous avons choisi de différencier l'implementation de la phase de
recrutement en fonction du tour pour éviter la présence d'une vérification du
tour à chaque fois que nous serions passé dans cet état.
Il en est de même pour la phase de sélection du premier joueur.

Nous avons choisi de faire de créer un état abstrait « GameState » pour
représenté un état du jeu, cet état doit stocker le GameBoard\footnote{Le GameBoard
  est une classe représentant le plateau de jeu. Voir \ref{description:modele}}
qui permet aux états d'intéragir sur le modèle (voir \ref{description:modele})


Dans l'UML suivant on retrouve les classes qui font partie du modèle, c'est à
dire qu'elles ne contiennent que des données.
Les classes faisant partie du modèle sont les suivantes:
\begin{itemize}
    \item Studio
    \item FactionType
    \item Player
    \item UnitBuffedCharacteristics
    \item UnitBasicCharacteristics
    \item UnitCostModifier
    \item UnitCounter
    \item Unit
    \item UnitType
    \item Zone
    \item UnitType
    \item GameMap
    \item UnitLevel
    \item GameBoard
    \item MarketingLadder
\end{itemize}

On retrouve également le système des buffs, chaque joueur possède un
BuffsManager qui permet de gérer les buffs.

Buff est une classe abstraite qui écoute des events et se charge d'ajouter un
BuffMask à la class « UnitBuffedCharacteristics » quand le buff doit
s'appliquer.
La classe UnitBasicCharacteristics définit les caractéristiques de base de l'unité.
Les classes filles de Buff sont créees et ajouté au BuffManager du
joueur lorsque le joueur lance une capacité.

Les SelfActivables et Activables permettent de débloquer les capacités des
joueurs au cours de la partie, lorsque les conditions qui doivent être remplies
pour activer les capacités sont remplies.


%TODO

